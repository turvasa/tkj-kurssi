main:   # %rax = %r11 * %r12
    irmovq stack,%rsp       # Initialize stack
    irmovq $01,%r10             # one = 1
    irmovq $0x01,%r9            # bit = 0x01
    irmovq $01,%r8              # count = 1

    call make_multiplier_smaller

    multi_loop:                 # while (true)
        rrmovq %r12,%r13        # multi = multiplier
        subq %r10,%r13          # if (multi == 0)
        jl end_multi            #    break

        rrmovq %r12,%r13        # multi = multiplier
        andq %r9,%r13           # if ((mulit & 0b01) == 0)
        je skip_multi           #    skip_multi

        rrmovq %r11,%rdi        # multic = multiplicand
        rrmovq %r8,%rsi         # countCpy = count
        jmp multiplicand_shift # multic << count
        end_shift:
        addq %rdi,%rax          # result += multic

    skip_multi:
        call move_multiplier    # multiplier >> 1
        addq %r10,%r8           # count++
        jmp multi_loop

    end_multi:
    halt


make_multiplier_smaller:    # %r11 <-> %r12, if %r12 > %r11
    rrmovq %r12,%r14            # multiplierCpy = multiplier
    subq %r11,%r14              # if (multiplierCpy <= multiplicand)
    jle skip_change             #    skip_change

    rrmovq %r12,%r14            # multiplierCpy = multiplier
    rrmovq %r11,%r12            # multiplier = multiplicand
    rrmovq %r14,%r11            # multiplicand = multiplierCpy
skip_change:
    ret


multiplicand_shift:     # multi << count
    shift_loop:              # while (true)
        subq %r10,%rsi          # if (count-- == 0)
        je end_shift            #    break
        addq %rdi,%rdi          # multi << 1
        jmp shift_loop


move_multiplier:        # multiplier >> 1
    rrmovq %r12,%rcx        # currentMulti = multplier
    irmovq $00,%rdi         # bitResult = 0
    irmovq $63,%rsi         # bitsToShift = 64 - 1

    result_loop:            # while (true)
        addq %rdi,%rdi          # bitResult << 1
        andq %rcx,%rcx          # if (currentResult >= 0)
        jge shift               #    jump to shift
        xorq %r10,%rdi          # bitReuslt ^= 1
    shift:
        addq %rcx,%rcx          # currentResult << 1
        subq %r10,%rsi          # if (bitsToShift-- < 0)
        jne result_loop         #    continue
        rrmovq %rdi,%r12        # result = bitResult
        ret


.pos 0x800
stack:
